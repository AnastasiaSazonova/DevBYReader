//
//  NewsRepository.m
//  DevBYReader
//
//  Created by Admin on 4/17/14.
//  Copyright (c) 2014 AD. All rights reserved.
//

#import "NewsRepository.h"

@implementation NewsRepository

- (NSArray *)getNewsList
{
    NSArray *newsList = @[
                    [[NewsModel alloc] initWithId:0 andTitle:@"Шесть парадигм программирования, которые изменят ваше представление о коде" andTime:@"14 апреля в 11:06" andImageName:@"img0.png"],
                    [[NewsModel alloc] initWithId:1 andTitle:@"Михаил Дубаков рассказал и показал десятилетнюю историю Targetprocess" andTime:@"11 апреля в 15:26" andImageName:@"img1.png"],
                    [[NewsModel alloc] initWithId:2 andTitle:@"Heartbleed – новое слово в маркетинге багов" andTime:@"10 апреля в 17:31" andImageName:@"img2.png"],
                    [[NewsModel alloc] initWithId:3 andTitle:@"Злой гений создал гибрид '2048' и 'Flappy Bird' на погибель вашей продуктивности" andTime:@"10 апреля в 16:44" andImageName:@"img3.png"],
                    [[NewsModel alloc] initWithId:4 andTitle:@"Биография Gmail: подлинная история запуска гуглопочты, которой недавно исполнилось 10 лет" andTime:@"07 апреля в 12:33" andImageName:@"img4.png"],
                    [[NewsModel alloc] initWithId:5 andTitle:@"Фотоотчет с IT Spring 2014: Люди, лего и город в лучах заката" andTime:@"09 апреля в 10:46" andImageName:@"img5.png"]
                    ];
    return newsList;
}

- (NewsDetailModel *)getNewsDetailModel:(NSInteger)newsId_
{
    NewsDetailModel *model = [[NewsDetailModel alloc] init];    
    
    switch (newsId_)
    {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            model.newsId = newsId_;
            model.author = @"Евгений Брикман";
            model.title = @"Шесть парадигм программирования, которые изменят ваше представление о коде";
            model.time = @"14 апреля в 11:06";
            model.description = @"Этот список эзотерических языков программирования с примерами кода определенно способен расширить ваше программерское сознание. А возможно и сподвигнет к изучению чего-нибудь эдакого в свободное от написания очередного энтерпрайз-приложения на Java или .NET.Мне регулярно приходится сталкиваться с языками программирования, которые работают настолько нетривиально, что приходится просто пересмотреть свои представления о том, что такое «программный код». В этом посте я хотел бы рассказать о самых интересных моих находках такого рода.Можете быть уверены, это не дедовский ностальгический пост в стиле «функциональное программирование изменит мир», собранные здесь языки гораздо более необычны. Рискну предположить, что многие читатели слыхом не слыхивали о большинстве описанных ниже языков и парадигм. Надеюсь, это знакомство окажется для вас не менее интересным, чем было для меня.            Обратите внимание: я обладаю минимальным опытом работы со всеми нижеперечисленными языками. Идеи, лежащие в их основе, кажутся мне интересными, но я не претендую на экспертное мнение по их поводу. Поэтому прошу указывать любые найденные ошибки и предлагать исправления. Если вы знаете и другие подобные идеи и парадигмы, не рассмотренные здесь – расскажите о них!            Конкурентность по умолчанию            Примеры языков: ANI, Plaid            Итак, давайте сразу начнем с настоящего парадокса: существуют языки программирования, в которых конкурентность применяется по умолчанию. То есть, любая строка кода выполняется параллельно!            Допустим, вы написали три строки кода: A, B и C:            A;            B;            C;            В большинстве языков программирования сначала будет выполнена строка A, затем B и, наконец, C. Но в языке наподобие ANI все три строки будут выполнены одновременно!            Поток выполнения или упорядочивание строк кода в ANI – всего лишь побочный эффект явных зависимостей, существующих между этими строками. Например, если в B будет ссылка на переменную, определенную в A, то A и C выполнятся одновременно, а B – только после того, как выполнится A.            Рассмотрим пример кода на языке ANI. Как описано в руководстве, программы на ANI состоят из «каналов» (pipe) и «защелок» (latch), используемых для управления аппаратными потоками и потоками данных. Синтаксис необычный и разобрать его непросто, причем язык скорее мертв, чем жив. Но его концепции кажутся интересными.            Вот пример 'Hello World' на языке ANI:            'Hello, World!' ->std.out            В терминологии ANI это означает, что мы посылаем объект 'Hello, World!'  (строку) в аппаратный поток std.out. А что получится, если мы пошлем в std.out еще одну строку?            'Hello, World!' ->std.out            'Goodbye, World!' ->std.out            Обе эти строки кода выполняются параллельно, поэтому они могут выйти на консоль в любом порядке. Рассмотрим, что получится, если мы используем в одной строке переменную и позже сошлемся на нее:            s = [string];            'Hello, World!' ->s;            s ->std.out;            В первой строке объявляется защелка s. Защелки немного напоминают переменные. Данная защелка содержит строку. Вторая строка кода отправляет текст 'Hello, World!'  в s, третья строка «отщелкивает» s и отсылает ее содержимое в std.out. Здесь мы видим неявное упорядочивание программы на ANI: поскольку каждая строка зависит от предыдущей, код будет выполняться именно в том порядке, в котором он записан.            В языке Plaid также заявлена поддержка конкурентности по умолчанию, но данный язык работает по модели прав доступа, описанной в этой статье. Права доступа позволяют выстроить поток выполнения. В Plaid также исследуются другие интересные концепции, в частности, программирование, ориентированное на состояние типов. В такой парадигме программирования изменение состояния является сущностью первого порядка: объекты определяются не как классы, а как последовательности состояний и переходов, которые могут быть проверены компилятором. Здесь мы наблюдаем интересную попытку представить время в языке программирования как конструкт первого порядка. Эта проблема рассматривается в лекции Рича Хики «Мы уже прибыли?»            В настоящее время бурно развиваются многоядерные технологии, и поддерживать конкурентность на должном уровне во многих языках все сложнее. ANI и Plaid позволяют заново взглянуть на эту проблему, а в перспективе значительно повысить производительность. Правда, остается вопрос о том, усложняется или упрощается управление конкурентностью при «параллелизме по умолчанию».            Зависимые типы            Примеры языков: Idris, Agda, Coq            Вероятно, вам привычны системы типов, существующие, например, в языках C или Java. Типы позволяют компилятору проверять, что представляет из себя переменная – например, содержит ли она целое число, список или строку. А что если бы компилятор также мог проверять, содержит ли переменная «положительное число», «список длиной 2» или «строку-палиндром»?            Именно такие идеи лежат в основе языков, использующих зависимые типы. Можно задать тип, способный проверять значение переменных во время компиляции. В библиотеке shapeless для Scala предоставляется экспериментальная поддержка зависимых типов (читай: пока не вполне доработанная). С ее помощью легко создать примеры использования таких типов.            Вот как можно объявить при помощи этой библиотеки тип Vector, содержащий значения 1, 2 и 3:            val l1 = 1 :#: 2 :#: 3 :#: VNil            Здесь создается переменная l1. Из ее сигнатуры типа понятно, что перед нами Vector, содержащий Ints, а также видно, что это Vector с длиной 3. Компилятор может использовать эту информацию для перехвата ошибок. Давайте задействуем в Vector метод vAdd для выполнения попарного сложения двух Vectors:            val l1 = 1 :#: 2 :#: 3 :#: VNil            val l2 = 1 :#: 2 :#: 3 :#: VNil            val l3 = l1 vAdd l2            // Итог: l3 = 2 :#: 4 :#: 6 :#: VNil            Вышеприведенный пример работает нормально, поскольку системе типов известно: оба Vectors имеют длину 3. Но если бы мы попытались сложить при помощи vAdd два Vectors разной длины, то получили бы ошибку во время компиляции, а не во время выполнения!            val l1 = 1 :#: 2 :#: 3 :#: VNil            val l2 = 1 :#: 2 :#: VNil            val l3 = l1 vAdd l2                       // Итог: возникает ошибка компиляции, так как невозможно попарно            // складывать одномерные массивы, имеющие разную длину            Библиотека Shapeless довольно интересна, но, на мой взгляд, в ней еще хватает шероховатостей. Она поддерживает лишь ограниченное подмножество зависимых типов. Кроме того, создаваемый с ее помощью код и сигнатуры типов получаются довольно пространными. В свою очередь, в языке Idris типы являются первоклассными сущностями, поэтому система зависимых типов представляется гораздо более мощной и аккуратной. Для сравнения можете ознакомиться с лекцией «Scala и Idris: зависимые типы сегодня и завтра».                       Существуют методы формальной верификации типа long, но они слишком неудобны для активного использования в повседневном программировании. Зависимые типы в таких языках, как Idris, а в будущем, вероятно, и в Scala, могут предложить более легковесные и практичные альтернативы для значительного повышения эффективности системы типов при отслеживании ошибок. Разумеется, никакая система зависимых типов не сможет перехватить все ошибки в силу неизбежных ограничений, обусловленных проблемой останова. Но при условии умелого применения зависимые типы могут стать новым большим скачком в системах статических типов.            Конкатенативные языки            Примеры языков: Forth, cat, joy            Вы когда-нибудь задумывались, как выглядела бы программа, не содержащая переменных и не использующая функций? Я – нет. Но оказалось, что даже такие идеи обсуждаются всерьез, и их сторонники сформулировали концепцию конкатенативного программирования. Основной смысл этой парадигмы таков: все сущности в языке являются функциями, помещающими информацию в стек. Программы выстраиваются практически исключительно при помощи функциональной композиции (конкатенация – это композиция).            На первый взгляд это кажется слишком абстрактным, так что давайте рассмотрим пример на языке cat:            2 3 +            Здесь мы помещаем в стек два числа, а затем вызываем функцию +, которая извлекает из стека оба числа, суммирует их, а потом записывает в стек результат их сложения. Вывод этого кода равен 5. А вот более интересный пример:            def foo {                10 <                [ 0 ]                [ 42 ]                if                    }             20            foo            Рассмотрим этот код построчно.            Сначала мы объявляем функцию foo. Обратите внимание: в языке cat для функций не указывается никаких параметров ввода, все параметры неявно считываются из стека.            foo вызывает функцию <, которая выводит на верхнюю позицию в стеке первый элемент, сравнивает его с 10, после чего возвращает в стек True или False.";
            break;
            
        default:
            break;
    }
    
    return model;
}

@end
